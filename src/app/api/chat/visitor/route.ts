import { NextRequest, NextResponse } from 'next/server'
import crypto from 'crypto'

const VISITOR_SECRET = process.env.VISITOR_SECRET || crypto.randomBytes(32).toString('base64')
const VISITOR_ID_TTL_MS = 30 * 24 * 60 * 60 * 1000 // 30 days

type VisitorIDPayload = {
  id: string
  timestamp: number
}

/**
 * Generate a cryptographically signed visitor ID.
 * Format: base64(id.timestamp).hmac
 * The HMAC ensures the ID was generated by the server and prevents tampering.
 */
const generateSignedVisitorId = (): string => {
  const rawId = crypto.randomBytes(12).toString('base64url')
  const timestamp = Date.now()
  const payload = `${rawId}.${timestamp}`

  const hmac = crypto
    .createHmac('sha256', VISITOR_SECRET)
    .update(payload)
    .digest('base64url')
    .slice(0, 16)

  return `${payload}.${hmac}`
}

/**
 * Verify a visitor ID was generated by the server and hasn't expired.
 */
export const verifyVisitorId = (visitorId: string): { valid: boolean; reason?: string } => {
  try {
    const parts = visitorId.split('.')
    if (parts.length !== 3) {
      return { valid: false, reason: 'invalid_format' }
    }

    const [rawId, timestampStr, providedHmac] = parts
    const payload = `${rawId}.${timestampStr}`

    // Verify HMAC
    const expectedHmac = crypto
      .createHmac('sha256', VISITOR_SECRET)
      .update(payload)
      .digest('base64url')
      .slice(0, 16)

    // Use timing-safe comparison
    if (!crypto.timingSafeEqual(Buffer.from(expectedHmac), Buffer.from(providedHmac))) {
      return { valid: false, reason: 'invalid_signature' }
    }

    // Check expiration
    const timestamp = Number.parseInt(timestampStr, 10)
    if (Number.isNaN(timestamp) || Date.now() - timestamp > VISITOR_ID_TTL_MS) {
      return { valid: false, reason: 'expired' }
    }

    return { valid: true }
  } catch {
    return { valid: false, reason: 'verification_failed' }
  }
}

export async function POST(req: NextRequest) {
  try {
    const visitorId = generateSignedVisitorId()

    return NextResponse.json({
      visitorId,
      expiresAt: Date.now() + VISITOR_ID_TTL_MS,
    })
  } catch {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
