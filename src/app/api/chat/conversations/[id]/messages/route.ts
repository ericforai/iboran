import { getPayload } from 'payload'
import { NextResponse } from 'next/server'

import config from '@payload-config'
import { checkRateLimit, getRequestIP } from '@/utilities/rateLimit'
import { verifyVisitorId } from '../../visitor/route'

export async function GET(req: Request, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params
    const { searchParams } = new URL(req.url)
    const requestedLimit = Number(searchParams.get('limit') || 80)
    const limit = Number.isFinite(requestedLimit) ? Math.max(1, Math.min(requestedLimit, 200)) : 80
    const payload = await getPayload({ config })
    const { user } = await payload.auth({ headers: req.headers })
    const ip = getRequestIP(req.headers)
    const limiterKey = user ? `chat-read-auth:${user.id}:${ip}` : `chat-read-visitor:${ip}`
    const limiter = checkRateLimit(limiterKey, { limit: 120, windowMs: 60_000 })
    if (!limiter.allowed) {
      return NextResponse.json(
        { error: 'Too many requests' },
        { status: 429, headers: { 'Retry-After': String(Math.ceil(limiter.retryAfterMs / 1000)) } },
      )
    }

    const conversation = await payload.findByID({
      collection: 'conversations',
      id,
      depth: 0,
    })
    if (!conversation) {
      return NextResponse.json({ error: 'Conversation not found' }, { status: 404 })
    }

    const role = user?.role
    const isAgent = role === 'agent' || role === 'admin'
    if (!isAgent) {
      const visitorId = req.headers.get('x-chat-visitor-id')?.trim()
      // Verify the visitor ID was generated by the server
      const verification = verifyVisitorId(visitorId || '')
      if (!verification.valid || visitorId !== conversation.visitorId) {
        return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
      }
    }

    const messages = await payload.find({
      collection: 'messages',
      where: {
        conversation: {
          equals: id,
        },
      },
      sort: 'createdAt',
      limit,
      pagination: false,
    })

    return NextResponse.json({ docs: messages.docs })
  } catch {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
  }
}
